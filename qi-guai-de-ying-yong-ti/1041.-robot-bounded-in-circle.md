# 1041. Robot Bounded In Circle

#### 1041. Robot Bounded In Circle

[https://leetcode.com/problems/robot-bounded-in-circle/](https://leetcode.com/problems/robot-bounded-in-circle/)

机器人从（0，0）位置**朝北**出发可以直走左转右转，问给一系列指令最后能否走一个circle。通过试几个例子就能发现只要机器人在follow完一轮指令后**不是朝着北，**那经过最多4轮必定会最后走回（0，0）形成circle。

### 数学证明：

> Let's say the robot starts with facing `up`. It moves `[dx, dy]` by executing the instructions once.  
> If the robot starts with facing  
> `right`, it moves `[dy, -dx]`;  
> `left`, it moves `[-dy, dx]`;  
> `down`, it moves `[-dx, -dy]`
>
> If the robot faces right \(clockwise 90 degree\) after executing the instructions once,  
> the direction sequence of executing the instructions repeatedly will be `up -> right -> down -> left -> up`  
> The resulting move is `[dx, dy] + [dy, -dx] + [-dx, -dy] + [-dy, dx] = [0, 0]` \(back to the original starting point\)
>
> All other possible direction sequences:  
> `up -> left -> down -> right -> up`. The resulting move is `[dx, dy] + [-dy, dx] + [-dx, -dy] + [dy, -dx] = [0, 0]`  
> `up -> down -> up`. The resulting move is `[dx, dy] + [-dx, -dy] = [0, 0]`  
> `up -> up`. The resulting move is `[dx, dy]`

### 答案代码：

```cpp
    bool isRobotBounded(string instructions) {
        int x = 0, y = 0;
        vector<vector<int>> direction = {{0,1}, {1,0}, {0,-1}, {-1,0}};
        int cur = 0; //current direction index
        for (int round=0; round<4; ++round) {
            for (char order : instructions) {
                if (order == 'L') {
                    cur = (cur + 3) % 4; // turn left means turn 270
                } else if (order == 'R') {
                    cur = (cur + 1) % 4; // turn right means turn 90
                } else {
                    x += direction[cur][0];
                    y += direction[cur][1];
                }
            }
        }
        return x==0 && y==0;
    }
```

